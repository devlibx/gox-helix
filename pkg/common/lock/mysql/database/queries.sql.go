// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package helixMysql

import (
	"context"
	"time"
)

const getLockByLockKey = `-- name: GetLockByLockKey :one
SELECT owner_id, expires_at, epoch
FROM helix_locks
WHERE lock_key = ?
  AND status = 'active'
`

type GetLockByLockKeyRow struct {
	OwnerID   string    `json:"owner_id"`
	ExpiresAt time.Time `json:"expires_at"`
	Epoch     int64     `json:"epoch"`
}

// GetLockByLockKey
//
//	SELECT owner_id, expires_at, epoch
//	FROM helix_locks
//	WHERE lock_key = ?
//	  AND status = 'active'
func (q *Queries) GetLockByLockKey(ctx context.Context, lockKey string) (*GetLockByLockKeyRow, error) {
	row := q.queryRow(ctx, q.getLockByLockKeyStmt, getLockByLockKey, lockKey)
	var i GetLockByLockKeyRow
	err := row.Scan(&i.OwnerID, &i.ExpiresAt, &i.Epoch)
	return &i, err
}

const tryUpsertLock = `-- name: TryUpsertLock :exec
INSERT INTO helix_locks (lock_key, owner_id, expires_at, epoch, status)
VALUES (?, ?, ?, 1, 'active')
ON DUPLICATE KEY
    UPDATE owner_id   = CASE WHEN expires_at < VALUES(expires_at) THEN VALUES(owner_id) ELSE owner_id END,
           expires_at = CASE WHEN expires_at < VALUES(expires_at) THEN VALUES(expires_at) ELSE expires_at END,
           epoch = CASE WHEN expires_at < VALUES(expires_at) THEN epoch + 1 ELSE epoch END
`

type TryUpsertLockParams struct {
	LockKey   string    `json:"lock_key"`
	OwnerID   string    `json:"owner_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

// TryUpsertLock
//
//	INSERT INTO helix_locks (lock_key, owner_id, expires_at, epoch, status)
//	VALUES (?, ?, ?, 1, 'active')
//	ON DUPLICATE KEY
//	    UPDATE owner_id   = CASE WHEN expires_at < VALUES(expires_at) THEN VALUES(owner_id) ELSE owner_id END,
//	           expires_at = CASE WHEN expires_at < VALUES(expires_at) THEN VALUES(expires_at) ELSE expires_at END,
//	           epoch = CASE WHEN expires_at < VALUES(expires_at) THEN epoch + 1 ELSE epoch END
func (q *Queries) TryUpsertLock(ctx context.Context, arg TryUpsertLockParams) error {
	_, err := q.exec(ctx, q.tryUpsertLockStmt, tryUpsertLock, arg.LockKey, arg.OwnerID, arg.ExpiresAt)
	return err
}
