// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package helixMysql

import (
	"context"
	"time"
)

const getLockByLockKey = `-- name: GetLockByLockKey :one
SELECT owner_id, expires_at, epoch
FROM helix_locks
WHERE lock_key = ?
  AND status = 1
`

type GetLockByLockKeyRow struct {
	OwnerID   string    `json:"owner_id"`
	ExpiresAt time.Time `json:"expires_at"`
	Epoch     int64     `json:"epoch"`
}

// GetLockByLockKey
//
//	SELECT owner_id, expires_at, epoch
//	FROM helix_locks
//	WHERE lock_key = ?
//	  AND status = 1
func (q *Queries) GetLockByLockKey(ctx context.Context, lockKey string) (*GetLockByLockKeyRow, error) {
	row := q.queryRow(ctx, q.getLockByLockKeyStmt, getLockByLockKey, lockKey)
	var i GetLockByLockKeyRow
	err := row.Scan(&i.OwnerID, &i.ExpiresAt, &i.Epoch)
	return &i, err
}

const tryUpsertLock = `-- name: TryUpsertLock :exec
INSERT INTO helix_locks (lock_key, owner_id, expires_at, epoch, status)
VALUES (?, ?, ?, 1, 1)
ON DUPLICATE KEY
    UPDATE owner_id   = IF(owner_id = VALUES(owner_id) OR expires_at < ?, VALUES(owner_id), owner_id),
           expires_at = IF(owner_id = VALUES(owner_id) OR expires_at < ?, VALUES(expires_at), expires_at),
           epoch      = IF(owner_id = VALUES(owner_id) OR expires_at < ?, epoch + 1, epoch)
`

type TryUpsertLockParams struct {
	LockKey     string    `json:"lock_key"`
	OwnerID     string    `json:"owner_id"`
	ExpiresAt   time.Time `json:"expires_at"`
	ExpiresAt_2 time.Time `json:"expires_at_2"`
	ExpiresAt_3 time.Time `json:"expires_at_3"`
	ExpiresAt_4 time.Time `json:"expires_at_4"`
}

// TryUpsertLock
//
//	INSERT INTO helix_locks (lock_key, owner_id, expires_at, epoch, status)
//	VALUES (?, ?, ?, 1, 1)
//	ON DUPLICATE KEY
//	    UPDATE owner_id   = IF(owner_id = VALUES(owner_id) OR expires_at < ?, VALUES(owner_id), owner_id),
//	           expires_at = IF(owner_id = VALUES(owner_id) OR expires_at < ?, VALUES(expires_at), expires_at),
//	           epoch      = IF(owner_id = VALUES(owner_id) OR expires_at < ?, epoch + 1, epoch)
func (q *Queries) TryUpsertLock(ctx context.Context, arg TryUpsertLockParams) error {
	_, err := q.exec(ctx, q.tryUpsertLockStmt, tryUpsertLock,
		arg.LockKey,
		arg.OwnerID,
		arg.ExpiresAt,
		arg.ExpiresAt_2,
		arg.ExpiresAt_3,
		arg.ExpiresAt_4,
	)
	return err
}
