// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package helixClusterMysql

import (
	"context"
	"database/sql"
	"time"
)

const deregisterNode = `-- name: DeregisterNode :exec
UPDATE helix_nodes
SET status  = 0,
    version = version + 1
WHERE cluster_name = ?
  AND node_uuid = ?
  AND status = 1
`

type DeregisterNodeParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

// DeregisterNode
//
//	UPDATE helix_nodes
//	SET status  = 0,
//	    version = version + 1
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND status = 1
func (q *Queries) DeregisterNode(ctx context.Context, arg DeregisterNodeParams) error {
	_, err := q.exec(ctx, q.deregisterNodeStmt, deregisterNode, arg.ClusterName, arg.NodeUuid)
	return err
}

const getActiveNodes = `-- name: GetActiveNodes :many
SELECT cluster_name,
       node_uuid,
       node_metadata,
       last_hb_time,
       status,
       version,
       created_at,
       updated_at
FROM helix_nodes
WHERE cluster_name = ?
  AND status = 1
`

type GetActiveNodesRow struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
	Status       int8           `json:"status"`
	Version      int32          `json:"version"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

// GetActiveNodes
//
//	SELECT cluster_name,
//	       node_uuid,
//	       node_metadata,
//	       last_hb_time,
//	       status,
//	       version,
//	       created_at,
//	       updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ?
//	  AND status = 1
func (q *Queries) GetActiveNodes(ctx context.Context, clusterName string) ([]*GetActiveNodesRow, error) {
	rows, err := q.query(ctx, q.getActiveNodesStmt, getActiveNodes, clusterName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveNodesRow{}
	for rows.Next() {
		var i GetActiveNodesRow
		if err := rows.Scan(
			&i.ClusterName,
			&i.NodeUuid,
			&i.NodeMetadata,
			&i.LastHbTime,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCluster = `-- name: GetCluster :one
SELECT cluster,
       domain,
       tasklist,
       metadata,
       partition_count,
       status,
       created_at,
       updated_at
FROM helix_cluster
WHERE cluster = ?
  AND domain = ?
  AND tasklist = ?
  AND status = 1
`

type GetClusterParams struct {
	Cluster  string `json:"cluster"`
	Domain   string `json:"domain"`
	Tasklist string `json:"tasklist"`
}

type GetClusterRow struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	Metadata       sql.NullString `json:"metadata"`
	PartitionCount uint32         `json:"partition_count"`
	Status         int8           `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// GetCluster
//
//	SELECT cluster,
//	       domain,
//	       tasklist,
//	       metadata,
//	       partition_count,
//	       status,
//	       created_at,
//	       updated_at
//	FROM helix_cluster
//	WHERE cluster = ?
//	  AND domain = ?
//	  AND tasklist = ?
//	  AND status = 1
func (q *Queries) GetCluster(ctx context.Context, arg GetClusterParams) (*GetClusterRow, error) {
	row := q.queryRow(ctx, q.getClusterStmt, getCluster, arg.Cluster, arg.Domain, arg.Tasklist)
	var i GetClusterRow
	err := row.Scan(
		&i.Cluster,
		&i.Domain,
		&i.Tasklist,
		&i.Metadata,
		&i.PartitionCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getClustersByDomain = `-- name: GetClustersByDomain :many
SELECT cluster,
       domain,
       tasklist,
       metadata,
       partition_count,
       status,
       created_at,
       updated_at
FROM helix_cluster
WHERE cluster = ?
  AND domain = ?
  AND status = 1
`

type GetClustersByDomainParams struct {
	Cluster string `json:"cluster"`
	Domain  string `json:"domain"`
}

type GetClustersByDomainRow struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	Metadata       sql.NullString `json:"metadata"`
	PartitionCount uint32         `json:"partition_count"`
	Status         int8           `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// GetClustersByDomain
//
//	SELECT cluster,
//	       domain,
//	       tasklist,
//	       metadata,
//	       partition_count,
//	       status,
//	       created_at,
//	       updated_at
//	FROM helix_cluster
//	WHERE cluster = ?
//	  AND domain = ?
//	  AND status = 1
func (q *Queries) GetClustersByDomain(ctx context.Context, arg GetClustersByDomainParams) ([]*GetClustersByDomainRow, error) {
	rows, err := q.query(ctx, q.getClustersByDomainStmt, getClustersByDomain, arg.Cluster, arg.Domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetClustersByDomainRow{}
	for rows.Next() {
		var i GetClustersByDomainRow
		if err := rows.Scan(
			&i.Cluster,
			&i.Domain,
			&i.Tasklist,
			&i.Metadata,
			&i.PartitionCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeById = `-- name: GetNodeById :one
SELECT id, cluster_name, node_uuid, node_metadata, last_hb_time, status, version, created_at, updated_at
FROM helix_nodes
WHERE cluster_name = ?
  AND node_uuid = ?
  AND status = 1
`

type GetNodeByIdParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

// GetNodeById
//
//	SELECT id, cluster_name, node_uuid, node_metadata, last_hb_time, status, version, created_at, updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND status = 1
func (q *Queries) GetNodeById(ctx context.Context, arg GetNodeByIdParams) (*HelixNode, error) {
	row := q.queryRow(ctx, q.getNodeByIdStmt, getNodeById, arg.ClusterName, arg.NodeUuid)
	var i HelixNode
	err := row.Scan(
		&i.ID,
		&i.ClusterName,
		&i.NodeUuid,
		&i.NodeMetadata,
		&i.LastHbTime,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const markInactiveNodes = `-- name: MarkInactiveNodes :exec
UPDATE helix_nodes
SET status  = 0,
    version = version + 1
WHERE cluster_name = ?
  AND status = 1
  AND last_hb_time < ?
`

type MarkInactiveNodesParams struct {
	ClusterName string    `json:"cluster_name"`
	LastHbTime  time.Time `json:"last_hb_time"`
}

// MarkInactiveNodes
//
//	UPDATE helix_nodes
//	SET status  = 0,
//	    version = version + 1
//	WHERE cluster_name = ?
//	  AND status = 1
//	  AND last_hb_time < ?
func (q *Queries) MarkInactiveNodes(ctx context.Context, arg MarkInactiveNodesParams) error {
	_, err := q.exec(ctx, q.markInactiveNodesStmt, markInactiveNodes, arg.ClusterName, arg.LastHbTime)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :execresult
UPDATE helix_nodes
SET last_hb_time = ?,
    status       = 1,
    version      = version + 1
WHERE cluster_name = ?
  AND node_uuid = ?
  AND (status = 1)
`

type UpdateHeartbeatParams struct {
	LastHbTime  time.Time `json:"last_hb_time"`
	ClusterName string    `json:"cluster_name"`
	NodeUuid    string    `json:"node_uuid"`
}

// UpdateHeartbeat
//
//	UPDATE helix_nodes
//	SET last_hb_time = ?,
//	    status       = 1,
//	    version      = version + 1
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND (status = 1)
func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) (sql.Result, error) {
	return q.exec(ctx, q.updateHeartbeatStmt, updateHeartbeat, arg.LastHbTime, arg.ClusterName, arg.NodeUuid)
}

const upsertCluster = `-- name: UpsertCluster :exec
INSERT INTO helix_cluster (cluster, domain, tasklist, partition_count, metadata, status)
VALUES (?, ?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE partition_count = VALUES(partition_count),
                        metadata        = VALUES(metadata),
                        status          = 1
`

type UpsertClusterParams struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	PartitionCount uint32         `json:"partition_count"`
	Metadata       sql.NullString `json:"metadata"`
}

// UpsertCluster
//
//	INSERT INTO helix_cluster (cluster, domain, tasklist, partition_count, metadata, status)
//	VALUES (?, ?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE partition_count = VALUES(partition_count),
//	                        metadata        = VALUES(metadata),
//	                        status          = 1
func (q *Queries) UpsertCluster(ctx context.Context, arg UpsertClusterParams) error {
	_, err := q.exec(ctx, q.upsertClusterStmt, upsertCluster,
		arg.Cluster,
		arg.Domain,
		arg.Tasklist,
		arg.PartitionCount,
		arg.Metadata,
	)
	return err
}

const upsertNode = `-- name: UpsertNode :exec
INSERT INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
VALUES (?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE node_metadata = VALUES(node_metadata),
                        last_hb_time  = VALUES(last_hb_time),
                        status        = 1
`

type UpsertNodeParams struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
}

// UpsertNode
//
//	INSERT INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
//	VALUES (?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE node_metadata = VALUES(node_metadata),
//	                        last_hb_time  = VALUES(last_hb_time),
//	                        status        = 1
func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) error {
	_, err := q.exec(ctx, q.upsertNodeStmt, upsertNode,
		arg.ClusterName,
		arg.NodeUuid,
		arg.NodeMetadata,
		arg.LastHbTime,
	)
	return err
}
