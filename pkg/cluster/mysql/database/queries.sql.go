// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package helixClusterMysql

import (
	"context"
	"database/sql"
	"time"
)

const deregisterNode = `-- name: DeregisterNode :exec
UPDATE helix_nodes 
SET status = 0
WHERE cluster_name = ? AND node_uuid = ? AND status = 1
`

type DeregisterNodeParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

// DeregisterNode
//
//	UPDATE helix_nodes
//	SET status = 0
//	WHERE cluster_name = ? AND node_uuid = ? AND status = 1
func (q *Queries) DeregisterNode(ctx context.Context, arg DeregisterNodeParams) error {
	_, err := q.exec(ctx, q.deregisterNodeStmt, deregisterNode, arg.ClusterName, arg.NodeUuid)
	return err
}

const getActiveNodes = `-- name: GetActiveNodes :many
SELECT cluster_name, node_uuid, node_metadata, last_hb_time, status, created_at, updated_at
FROM helix_nodes
WHERE cluster_name = ? AND status = 1
`

type GetActiveNodesRow struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
	Status       int8           `json:"status"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

// GetActiveNodes
//
//	SELECT cluster_name, node_uuid, node_metadata, last_hb_time, status, created_at, updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ? AND status = 1
func (q *Queries) GetActiveNodes(ctx context.Context, clusterName string) ([]*GetActiveNodesRow, error) {
	rows, err := q.query(ctx, q.getActiveNodesStmt, getActiveNodes, clusterName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveNodesRow{}
	for rows.Next() {
		var i GetActiveNodesRow
		if err := rows.Scan(
			&i.ClusterName,
			&i.NodeUuid,
			&i.NodeMetadata,
			&i.LastHbTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeById = `-- name: GetNodeById :one
SELECT cluster_name, node_uuid, node_metadata, last_hb_time, status, created_at, updated_at
FROM helix_nodes
WHERE cluster_name = ? AND node_uuid = ? AND status = 1
`

type GetNodeByIdParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

type GetNodeByIdRow struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
	Status       int8           `json:"status"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

// GetNodeById
//
//	SELECT cluster_name, node_uuid, node_metadata, last_hb_time, status, created_at, updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ? AND node_uuid = ? AND status = 1
func (q *Queries) GetNodeById(ctx context.Context, arg GetNodeByIdParams) (*GetNodeByIdRow, error) {
	row := q.queryRow(ctx, q.getNodeByIdStmt, getNodeById, arg.ClusterName, arg.NodeUuid)
	var i GetNodeByIdRow
	err := row.Scan(
		&i.ClusterName,
		&i.NodeUuid,
		&i.NodeMetadata,
		&i.LastHbTime,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const markInactiveNodes = `-- name: MarkInactiveNodes :exec
UPDATE helix_nodes 
SET status = 0
WHERE cluster_name = ? AND status = 1 AND last_hb_time < ?
`

type MarkInactiveNodesParams struct {
	ClusterName string    `json:"cluster_name"`
	LastHbTime  time.Time `json:"last_hb_time"`
}

// MarkInactiveNodes
//
//	UPDATE helix_nodes
//	SET status = 0
//	WHERE cluster_name = ? AND status = 1 AND last_hb_time < ?
func (q *Queries) MarkInactiveNodes(ctx context.Context, arg MarkInactiveNodesParams) error {
	_, err := q.exec(ctx, q.markInactiveNodesStmt, markInactiveNodes, arg.ClusterName, arg.LastHbTime)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :exec
UPDATE helix_nodes 
SET last_hb_time = ?, status = 1
WHERE cluster_name = ? AND node_uuid = ? AND (status = 1 OR status = 0)
`

type UpdateHeartbeatParams struct {
	LastHbTime  time.Time `json:"last_hb_time"`
	ClusterName string    `json:"cluster_name"`
	NodeUuid    string    `json:"node_uuid"`
}

// UpdateHeartbeat
//
//	UPDATE helix_nodes
//	SET last_hb_time = ?, status = 1
//	WHERE cluster_name = ? AND node_uuid = ? AND (status = 1 OR status = 0)
func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) error {
	_, err := q.exec(ctx, q.updateHeartbeatStmt, updateHeartbeat, arg.LastHbTime, arg.ClusterName, arg.NodeUuid)
	return err
}

const upsertNode = `-- name: UpsertNode :exec
INSERT INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
VALUES (?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE
    node_metadata = VALUES(node_metadata),
    last_hb_time = VALUES(last_hb_time),
    status = 1
`

type UpsertNodeParams struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
}

// UpsertNode
//
//	INSERT INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
//	VALUES (?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE
//	    node_metadata = VALUES(node_metadata),
//	    last_hb_time = VALUES(last_hb_time),
//	    status = 1
func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) error {
	_, err := q.exec(ctx, q.upsertNodeStmt, upsertNode,
		arg.ClusterName,
		arg.NodeUuid,
		arg.NodeMetadata,
		arg.LastHbTime,
	)
	return err
}
