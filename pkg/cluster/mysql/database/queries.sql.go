// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package helixClusterMysql

import (
	"context"
	"database/sql"
	"time"
)

const deregisterNode = `-- name: DeregisterNode :exec
UPDATE helix_nodes /*+ MAX_EXECUTION_TIME(1000) */
SET status  = 0,
    version = version + 1
WHERE cluster_name = ?
  AND node_uuid = ?
  AND status = 1
`

type DeregisterNodeParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

// DeregisterNode
//
//	UPDATE helix_nodes /*+ MAX_EXECUTION_TIME(1000) */
//	SET status  = 0,
//	    version = version + 1
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND status = 1
func (q *Queries) DeregisterNode(ctx context.Context, arg DeregisterNodeParams) error {
	_, err := q.exec(ctx, q.deregisterNodeStmt, deregisterNode, arg.ClusterName, arg.NodeUuid)
	return err
}

const getActiveNodes = `-- name: GetActiveNodes :many
SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster_name,
       node_uuid,
       node_metadata,
       last_hb_time,
       status,
       version,
       created_at,
       updated_at
FROM helix_nodes
WHERE cluster_name = ?
  AND status = 1
`

type GetActiveNodesRow struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
	Status       int8           `json:"status"`
	Version      int32          `json:"version"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

// GetActiveNodes
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster_name,
//	       node_uuid,
//	       node_metadata,
//	       last_hb_time,
//	       status,
//	       version,
//	       created_at,
//	       updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ?
//	  AND status = 1
func (q *Queries) GetActiveNodes(ctx context.Context, clusterName string) ([]*GetActiveNodesRow, error) {
	rows, err := q.query(ctx, q.getActiveNodesStmt, getActiveNodes, clusterName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveNodesRow{}
	for rows.Next() {
		var i GetActiveNodesRow
		if err := rows.Scan(
			&i.ClusterName,
			&i.NodeUuid,
			&i.NodeMetadata,
			&i.LastHbTime,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDomainsAndTaskListsByClusterCname = `-- name: GetAllDomainsAndTaskListsByClusterCname :many
SELECT /*+ MAX_EXECUTION_TIME(1000) */ id, cluster, domain, tasklist, metadata, partition_count, status, created_at, updated_at
FROM helix_cluster
WHERE cluster = ?
  AND status = 1
`

// GetAllDomainsAndTaskListsByClusterCname
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ id, cluster, domain, tasklist, metadata, partition_count, status, created_at, updated_at
//	FROM helix_cluster
//	WHERE cluster = ?
//	  AND status = 1
func (q *Queries) GetAllDomainsAndTaskListsByClusterCname(ctx context.Context, cluster string) ([]*HelixCluster, error) {
	rows, err := q.query(ctx, q.getAllDomainsAndTaskListsByClusterCnameStmt, getAllDomainsAndTaskListsByClusterCname, cluster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*HelixCluster{}
	for rows.Next() {
		var i HelixCluster
		if err := rows.Scan(
			&i.ID,
			&i.Cluster,
			&i.Domain,
			&i.Tasklist,
			&i.Metadata,
			&i.PartitionCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllocationById = `-- name: GetAllocationById :one
SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
       cluster,
       domain,
       tasklist,
       node_id,
       status,
       partition_info,
       metadata,
       created_at,
       updated_at
FROM helix_allocation
WHERE id = ?
  AND status = ?
`

type GetAllocationByIdParams struct {
	ID     uint64 `json:"id"`
	Status int8   `json:"status"`
}

// GetAllocationById
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
//	       cluster,
//	       domain,
//	       tasklist,
//	       node_id,
//	       status,
//	       partition_info,
//	       metadata,
//	       created_at,
//	       updated_at
//	FROM helix_allocation
//	WHERE id = ?
//	  AND status = ?
func (q *Queries) GetAllocationById(ctx context.Context, arg GetAllocationByIdParams) (*HelixAllocation, error) {
	row := q.queryRow(ctx, q.getAllocationByIdStmt, getAllocationById, arg.ID, arg.Status)
	var i HelixAllocation
	err := row.Scan(
		&i.ID,
		&i.Cluster,
		&i.Domain,
		&i.Tasklist,
		&i.NodeID,
		&i.Status,
		&i.PartitionInfo,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAllocationByNodeId = `-- name: GetAllocationByNodeId :one
SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
       cluster,
       domain,
       tasklist,
       node_id,
       status,
       partition_info,
       metadata,
       created_at,
       updated_at
FROM helix_allocation
WHERE node_id = ?
  AND status = 1
`

// GetAllocationByNodeId
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
//	       cluster,
//	       domain,
//	       tasklist,
//	       node_id,
//	       status,
//	       partition_info,
//	       metadata,
//	       created_at,
//	       updated_at
//	FROM helix_allocation
//	WHERE node_id = ?
//	  AND status = 1
func (q *Queries) GetAllocationByNodeId(ctx context.Context, nodeID string) (*HelixAllocation, error) {
	row := q.queryRow(ctx, q.getAllocationByNodeIdStmt, getAllocationByNodeId, nodeID)
	var i HelixAllocation
	err := row.Scan(
		&i.ID,
		&i.Cluster,
		&i.Domain,
		&i.Tasklist,
		&i.NodeID,
		&i.Status,
		&i.PartitionInfo,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAllocationsForTasklist = `-- name: GetAllocationsForTasklist :many
SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
       cluster,
       domain,
       tasklist,
       node_id,
       status,
       partition_info,
       metadata,
       created_at,
       updated_at
FROM helix_allocation
WHERE cluster = ?
  AND domain = ?
  AND tasklist = ?
  AND status = 1
`

type GetAllocationsForTasklistParams struct {
	Cluster  string `json:"cluster"`
	Domain   string `json:"domain"`
	Tasklist string `json:"tasklist"`
}

// GetAllocationsForTasklist
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ id,
//	       cluster,
//	       domain,
//	       tasklist,
//	       node_id,
//	       status,
//	       partition_info,
//	       metadata,
//	       created_at,
//	       updated_at
//	FROM helix_allocation
//	WHERE cluster = ?
//	  AND domain = ?
//	  AND tasklist = ?
//	  AND status = 1
func (q *Queries) GetAllocationsForTasklist(ctx context.Context, arg GetAllocationsForTasklistParams) ([]*HelixAllocation, error) {
	rows, err := q.query(ctx, q.getAllocationsForTasklistStmt, getAllocationsForTasklist, arg.Cluster, arg.Domain, arg.Tasklist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*HelixAllocation{}
	for rows.Next() {
		var i HelixAllocation
		if err := rows.Scan(
			&i.ID,
			&i.Cluster,
			&i.Domain,
			&i.Tasklist,
			&i.NodeID,
			&i.Status,
			&i.PartitionInfo,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCluster = `-- name: GetCluster :one
SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster,
       domain,
       tasklist,
       metadata,
       partition_count,
       status,
       created_at,
       updated_at
FROM helix_cluster
WHERE cluster = ?
  AND domain = ?
  AND tasklist = ?
  AND status = 1
`

type GetClusterParams struct {
	Cluster  string `json:"cluster"`
	Domain   string `json:"domain"`
	Tasklist string `json:"tasklist"`
}

type GetClusterRow struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	Metadata       sql.NullString `json:"metadata"`
	PartitionCount uint32         `json:"partition_count"`
	Status         int8           `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// GetCluster
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster,
//	       domain,
//	       tasklist,
//	       metadata,
//	       partition_count,
//	       status,
//	       created_at,
//	       updated_at
//	FROM helix_cluster
//	WHERE cluster = ?
//	  AND domain = ?
//	  AND tasklist = ?
//	  AND status = 1
func (q *Queries) GetCluster(ctx context.Context, arg GetClusterParams) (*GetClusterRow, error) {
	row := q.queryRow(ctx, q.getClusterStmt, getCluster, arg.Cluster, arg.Domain, arg.Tasklist)
	var i GetClusterRow
	err := row.Scan(
		&i.Cluster,
		&i.Domain,
		&i.Tasklist,
		&i.Metadata,
		&i.PartitionCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getClustersByDomain = `-- name: GetClustersByDomain :many
SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster,
       domain,
       tasklist,
       metadata,
       partition_count,
       status,
       created_at,
       updated_at
FROM helix_cluster
WHERE cluster = ?
  AND domain = ?
  AND status = 1
`

type GetClustersByDomainParams struct {
	Cluster string `json:"cluster"`
	Domain  string `json:"domain"`
}

type GetClustersByDomainRow struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	Metadata       sql.NullString `json:"metadata"`
	PartitionCount uint32         `json:"partition_count"`
	Status         int8           `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// GetClustersByDomain
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ cluster,
//	       domain,
//	       tasklist,
//	       metadata,
//	       partition_count,
//	       status,
//	       created_at,
//	       updated_at
//	FROM helix_cluster
//	WHERE cluster = ?
//	  AND domain = ?
//	  AND status = 1
func (q *Queries) GetClustersByDomain(ctx context.Context, arg GetClustersByDomainParams) ([]*GetClustersByDomainRow, error) {
	rows, err := q.query(ctx, q.getClustersByDomainStmt, getClustersByDomain, arg.Cluster, arg.Domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetClustersByDomainRow{}
	for rows.Next() {
		var i GetClustersByDomainRow
		if err := rows.Scan(
			&i.Cluster,
			&i.Domain,
			&i.Tasklist,
			&i.Metadata,
			&i.PartitionCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeById = `-- name: GetNodeById :one
SELECT /*+ MAX_EXECUTION_TIME(1000) */ id, cluster_name, node_uuid, node_metadata, last_hb_time, status, version, created_at, updated_at
FROM helix_nodes
WHERE cluster_name = ?
  AND node_uuid = ?
  AND status = 1
`

type GetNodeByIdParams struct {
	ClusterName string `json:"cluster_name"`
	NodeUuid    string `json:"node_uuid"`
}

// GetNodeById
//
//	SELECT /*+ MAX_EXECUTION_TIME(1000) */ id, cluster_name, node_uuid, node_metadata, last_hb_time, status, version, created_at, updated_at
//	FROM helix_nodes
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND status = 1
func (q *Queries) GetNodeById(ctx context.Context, arg GetNodeByIdParams) (*HelixNode, error) {
	row := q.queryRow(ctx, q.getNodeByIdStmt, getNodeById, arg.ClusterName, arg.NodeUuid)
	var i HelixNode
	err := row.Scan(
		&i.ID,
		&i.ClusterName,
		&i.NodeUuid,
		&i.NodeMetadata,
		&i.LastHbTime,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const markInactiveNodes = `-- name: MarkInactiveNodes :exec
UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_nodes
SET status  = 0,
    version = version + 1
WHERE cluster_name = ?
  AND status = 1
  AND last_hb_time < ?
`

type MarkInactiveNodesParams struct {
	ClusterName string    `json:"cluster_name"`
	LastHbTime  time.Time `json:"last_hb_time"`
}

// MarkInactiveNodes
//
//	UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_nodes
//	SET status  = 0,
//	    version = version + 1
//	WHERE cluster_name = ?
//	  AND status = 1
//	  AND last_hb_time < ?
func (q *Queries) MarkInactiveNodes(ctx context.Context, arg MarkInactiveNodesParams) error {
	_, err := q.exec(ctx, q.markInactiveNodesStmt, markInactiveNodes, arg.ClusterName, arg.LastHbTime)
	return err
}

const markNodeDeletable = `-- name: MarkNodeDeletable :exec
UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_allocation
SET status = 2
WHERE node_id = ?
  AND status = 0
`

// MarkNodeDeletable
//
//	UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_allocation
//	SET status = 2
//	WHERE node_id = ?
//	  AND status = 0
func (q *Queries) MarkNodeDeletable(ctx context.Context, nodeID string) error {
	_, err := q.exec(ctx, q.markNodeDeletableStmt, markNodeDeletable, nodeID)
	return err
}

const markNodeInactive = `-- name: MarkNodeInactive :exec
UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_allocation
SET status = 0
WHERE node_id = ?
  AND status = 1
`

// MarkNodeInactive
//
//	UPDATE /*+ MAX_EXECUTION_TIME(1000) */ helix_allocation
//	SET status = 0
//	WHERE node_id = ?
//	  AND status = 1
func (q *Queries) MarkNodeInactive(ctx context.Context, nodeID string) error {
	_, err := q.exec(ctx, q.markNodeInactiveStmt, markNodeInactive, nodeID)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :execresult
UPDATE helix_nodes /*+ MAX_EXECUTION_TIME(1000) */
SET last_hb_time = ?,
    version      = version + 1
WHERE cluster_name = ?
  AND node_uuid = ?
  AND status = 1
`

type UpdateHeartbeatParams struct {
	LastHbTime  time.Time `json:"last_hb_time"`
	ClusterName string    `json:"cluster_name"`
	NodeUuid    string    `json:"node_uuid"`
}

// UpdateHeartbeat
//
//	UPDATE helix_nodes /*+ MAX_EXECUTION_TIME(1000) */
//	SET last_hb_time = ?,
//	    version      = version + 1
//	WHERE cluster_name = ?
//	  AND node_uuid = ?
//	  AND status = 1
func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) (sql.Result, error) {
	return q.exec(ctx, q.updateHeartbeatStmt, updateHeartbeat, arg.LastHbTime, arg.ClusterName, arg.NodeUuid)
}

const upsertAllocation = `-- name: UpsertAllocation :exec
INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_allocation (cluster, domain, tasklist, node_id, partition_info, metadata, status)
VALUES (?, ?, ?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE partition_info = VALUES(partition_info),
                        metadata       = VALUES(metadata),
                        status         = 1
`

type UpsertAllocationParams struct {
	Cluster       string         `json:"cluster"`
	Domain        string         `json:"domain"`
	Tasklist      string         `json:"tasklist"`
	NodeID        string         `json:"node_id"`
	PartitionInfo string         `json:"partition_info"`
	Metadata      sql.NullString `json:"metadata"`
}

// UpsertAllocation
//
//	INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_allocation (cluster, domain, tasklist, node_id, partition_info, metadata, status)
//	VALUES (?, ?, ?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE partition_info = VALUES(partition_info),
//	                        metadata       = VALUES(metadata),
//	                        status         = 1
func (q *Queries) UpsertAllocation(ctx context.Context, arg UpsertAllocationParams) error {
	_, err := q.exec(ctx, q.upsertAllocationStmt, upsertAllocation,
		arg.Cluster,
		arg.Domain,
		arg.Tasklist,
		arg.NodeID,
		arg.PartitionInfo,
		arg.Metadata,
	)
	return err
}

const upsertCluster = `-- name: UpsertCluster :exec
INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_cluster (cluster, domain, tasklist, partition_count, metadata, status)
VALUES (?, ?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE partition_count = VALUES(partition_count),
                        metadata        = VALUES(metadata),
                        status          = 1
`

type UpsertClusterParams struct {
	Cluster        string         `json:"cluster"`
	Domain         string         `json:"domain"`
	Tasklist       string         `json:"tasklist"`
	PartitionCount uint32         `json:"partition_count"`
	Metadata       sql.NullString `json:"metadata"`
}

// UpsertCluster
//
//	INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_cluster (cluster, domain, tasklist, partition_count, metadata, status)
//	VALUES (?, ?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE partition_count = VALUES(partition_count),
//	                        metadata        = VALUES(metadata),
//	                        status          = 1
func (q *Queries) UpsertCluster(ctx context.Context, arg UpsertClusterParams) error {
	_, err := q.exec(ctx, q.upsertClusterStmt, upsertCluster,
		arg.Cluster,
		arg.Domain,
		arg.Tasklist,
		arg.PartitionCount,
		arg.Metadata,
	)
	return err
}

const upsertNode = `-- name: UpsertNode :exec
INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
VALUES (?, ?, ?, ?, 1)
ON DUPLICATE KEY UPDATE node_metadata = VALUES(node_metadata),
                        last_hb_time  = VALUES(last_hb_time),
                        status        = 1
`

type UpsertNodeParams struct {
	ClusterName  string         `json:"cluster_name"`
	NodeUuid     string         `json:"node_uuid"`
	NodeMetadata sql.NullString `json:"node_metadata"`
	LastHbTime   time.Time      `json:"last_hb_time"`
}

// UpsertNode
//
//	INSERT /*+ MAX_EXECUTION_TIME(1000) */ INTO helix_nodes (cluster_name, node_uuid, node_metadata, last_hb_time, status)
//	VALUES (?, ?, ?, ?, 1)
//	ON DUPLICATE KEY UPDATE node_metadata = VALUES(node_metadata),
//	                        last_hb_time  = VALUES(last_hb_time),
//	                        status        = 1
func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) error {
	_, err := q.exec(ctx, q.upsertNodeStmt, upsertNode,
		arg.ClusterName,
		arg.NodeUuid,
		arg.NodeMetadata,
		arg.LastHbTime,
	)
	return err
}
