// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"
)

const createDomain = `-- name: CreateDomain :exec
INSERT INTO domains (name)
VALUES (?)
`

func (q *Queries) CreateDomain(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createDomain, name)
	return err
}

const createPartition = `-- name: CreatePartition :exec
INSERT INTO partitions (queue_id, name)
VALUES (?, ?)
`

type CreatePartitionParams struct {
	QueueID int64
	Name    string
}

func (q *Queries) CreatePartition(ctx context.Context, arg CreatePartitionParams) error {
	_, err := q.db.ExecContext(ctx, createPartition, arg.QueueID, arg.Name)
	return err
}

const createQueue = `-- name: CreateQueue :exec
INSERT INTO queues (domain_id, name)
VALUES (?, ?)
`

type CreateQueueParams struct {
	DomainID int64
	Name     string
}

func (q *Queries) CreateQueue(ctx context.Context, arg CreateQueueParams) error {
	_, err := q.db.ExecContext(ctx, createQueue, arg.DomainID, arg.Name)
	return err
}

const getDomain = `-- name: GetDomain :one
SELECT id, name, created_at, updated_at FROM domains
WHERE id = ?
`

func (q *Queries) GetDomain(ctx context.Context, id int64) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomain, id)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPartition = `-- name: GetPartition :one
SELECT id, queue_id, name, created_at, updated_at FROM partitions
WHERE id = ?
`

func (q *Queries) GetPartition(ctx context.Context, id int64) (Partition, error) {
	row := q.db.QueryRowContext(ctx, getPartition, id)
	var i Partition
	err := row.Scan(
		&i.ID,
		&i.QueueID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQueue = `-- name: GetQueue :one
SELECT id, domain_id, name, created_at, updated_at FROM queues
WHERE id = ?
`

func (q *Queries) GetQueue(ctx context.Context, id int64) (Queue, error) {
	row := q.db.QueryRowContext(ctx, getQueue, id)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.DomainID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDomains = `-- name: ListDomains :many
SELECT id, name, created_at, updated_at FROM domains
ORDER BY name
`

func (q *Queries) ListDomains(ctx context.Context) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, listDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Domain
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPartitions = `-- name: ListPartitions :many
SELECT id, queue_id, name, created_at, updated_at FROM partitions
WHERE queue_id = ?
ORDER BY name
`

func (q *Queries) ListPartitions(ctx context.Context, queueID int64) ([]Partition, error) {
	rows, err := q.db.QueryContext(ctx, listPartitions, queueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Partition
	for rows.Next() {
		var i Partition
		if err := rows.Scan(
			&i.ID,
			&i.QueueID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueues = `-- name: ListQueues :many
SELECT id, domain_id, name, created_at, updated_at FROM queues
WHERE domain_id = ?
ORDER BY name
`

func (q *Queries) ListQueues(ctx context.Context, domainID int64) ([]Queue, error) {
	rows, err := q.db.QueryContext(ctx, listQueues, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Queue
	for rows.Next() {
		var i Queue
		if err := rows.Scan(
			&i.ID,
			&i.DomainID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
